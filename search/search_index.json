{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"../../README.md","title":"Home"},{"location":"intro/","text":"Introduction zend-memory assists with managing data in an environment with limited memory. Memory objects (memory containers) are generated by the memory manager at your request and transparently swapped/loaded when necessary. For example, if creating or loading a managed object would cause the total memory usage to exceed the limit you specify, some managed objects are copied to cache storage outside of memory. In this way, the total memory used by managed objects does not exceed the limit you need to enforce. To provide this functionality, the memory manager can compose zend-cache storage adapters as storage providers. Usage Instantiate the memory manager class: use Zend\\Memory\\MemoryManager; // No caching backend: $memoryManager = new MemoryManager(); Optionally, you can create a cache storage adapter, and pass it to the MemoryManager constructor: use Zend\\Cache\\StorageFactory; use Zend\\Memory\\MemoryManager; // Use a filesystem adapter, placing memory blocks in the tmp directory // under which the application is running. $cache = StorageFactory::factory([ 'adapter' => [ 'name' => 'filesystem', 'options' => ['cache_dir' => './tmp/'], ], ]); $memoryManager = new MemoryManager($cache); Once you have a MemoryManager instance, you can start pushing values to it and pulling values from it. $loadedFiles = array(); for ($count = 0; $count < 10000; $count++) { $f = fopen($fileNames[$count], 'rb'); $data = fread($f, filesize($fileNames[$count])); $fclose($f); $loadedFiles[] = $memoryManager->create($data); } echo $loadedFiles[$index1]->value; $loadedFiles[$index2]->value = $newValue; $loadedFiles[$index3]->value[$charIndex] = '_'; Theory of Operation zend-memory operates with the following concepts: Memory manager Memory container Locked memory object Movable memory object Memory manager The memory manager generates memory objects (locked or movable) by request of the application, and returns them wrapped into a memory container object. Memory container The memory container has a virtual or actual value attribute of type string . This attribute contains the data value specified at memory object creation time. You can operate with this value attribute as an object property: $memObject = $memoryManager->create($data); echo $memObject->value; $memObject->value = $newValue; $memObject->value[$index] = '_'; echo ord($memObject->value[$index1]); $memObject->value = substr($memObject->value, $start, $length); Locked memory Locked memory objects are always stored in memory. Data stored in locked memory are never swapped to the cache backend. Movable memory Movable memory objects are transparently swapped and loaded to/from the cache backend by the MemoryManager when necessary. The memory manager does not swap objects with size less than the specified minimum, due to performance considerations. See the settings section for more details.","title":"Intro"},{"location":"intro/#introduction","text":"zend-memory assists with managing data in an environment with limited memory. Memory objects (memory containers) are generated by the memory manager at your request and transparently swapped/loaded when necessary. For example, if creating or loading a managed object would cause the total memory usage to exceed the limit you specify, some managed objects are copied to cache storage outside of memory. In this way, the total memory used by managed objects does not exceed the limit you need to enforce. To provide this functionality, the memory manager can compose zend-cache storage adapters as storage providers.","title":"Introduction"},{"location":"intro/#usage","text":"Instantiate the memory manager class: use Zend\\Memory\\MemoryManager; // No caching backend: $memoryManager = new MemoryManager(); Optionally, you can create a cache storage adapter, and pass it to the MemoryManager constructor: use Zend\\Cache\\StorageFactory; use Zend\\Memory\\MemoryManager; // Use a filesystem adapter, placing memory blocks in the tmp directory // under which the application is running. $cache = StorageFactory::factory([ 'adapter' => [ 'name' => 'filesystem', 'options' => ['cache_dir' => './tmp/'], ], ]); $memoryManager = new MemoryManager($cache); Once you have a MemoryManager instance, you can start pushing values to it and pulling values from it. $loadedFiles = array(); for ($count = 0; $count < 10000; $count++) { $f = fopen($fileNames[$count], 'rb'); $data = fread($f, filesize($fileNames[$count])); $fclose($f); $loadedFiles[] = $memoryManager->create($data); } echo $loadedFiles[$index1]->value; $loadedFiles[$index2]->value = $newValue; $loadedFiles[$index3]->value[$charIndex] = '_';","title":"Usage"},{"location":"intro/#theory-of-operation","text":"zend-memory operates with the following concepts: Memory manager Memory container Locked memory object Movable memory object","title":"Theory of Operation"},{"location":"memory-manager/","text":"Memory Manager Creating a Memory Manager You can create new a memory manager ( Zend\\Memory\\MemoryManager object) using its constructor: __construct(Zend\\Cache\\Storage\\StorageInterface $cache = null) : void As an example, the following creates an instance which is not backed by cache storage: $memoryManager = new Zend\\Memory\\MemoryManager(); While the following creates an instance backed by a filesystem cache storage adapter, storing memory blocks in the tmp/ directory of the current working directory: use Zend\\Cache\\StorageFactory; use Zend\\Memory\\MemoryManager; $cache = StorageFactory::factory([ 'adapter' => [ 'name' => 'Filesystem', 'options' => [ 'cache_dir' => './tmp/', // Directory in which to put swapped memory blocks ], ], ]); $memoryManager = new MemoryManager($cache); The MemoryManager uses zend-cache storage adapters to cache memory blocks; if no cache instance is provided, the system temporary directory is used. This is useful if you know that memory is not limited or the overall size of objects never reaches the memory limit. Managing Memory Objects This section describes creating and destroying objects in the managed memory, and settings to control memory manager behavior. Creating Movable Objects Create movable objects (objects which may be swapped into cache storage) using the Zend\\Memory\\MemoryManager::create([$data]) method: $memObject = $memoryManager->create($data); The $data argument is optional and used to initialize the object value. If the $data argument is omitted, the value is an empty string. Creating Locked Objects Create locked objects (objects which will never be swapped into cache storage) using the Zend\\Memory\\MemoryManager::createLocked([$data]) method: $memObject = $memoryManager->createLocked($data); The $data argument is optional and used to initialize the object value. If the $data argument is omitted, the value is an empty string. Destroying Objects Memory objects are automatically destroyed and removed from memory when they go out of scope: function foo() use ($memoryManager, $memList) { // ... $memObject1 = $memoryManager->create($data1); $memObject2 = $memoryManager->create($data2); $memObject3 = $memoryManager->create($data3); // ... $memList[] = $memObject3; // ... unset($memObject2); // $memObject2 is destroyed here // ... // $memObject1 is destroyed here // but $memObject3 object is still referenced by $memList // and is not destroyed } This applies to both movable and locked objects. Settings Memory Limit The memory limit is the maximum number of bytes allowed for use by loaded movable objects. If loading or creation of an object causes memory usage to exceed of this limit, then the memory manager swaps some other objects. You can retrieve or set the memory limit setting using the getMemoryLimit() and setMemoryLimit($newLimit) methods: $oldLimit = $memoryManager->getMemoryLimit(); // Get memory limit in bytes $memoryManager->setMemoryLimit($newLimit); // Set memory limit in bytes A negative value for memory limit means 'no limit'. The default value is two-thirds of the value of memory_limit in php.ini or 'no limit' (-1) if memory_limit is not set in php.ini . MinSize The MinSize is the minimum size an object must be before it will be swapped to a cache backend; objects with sizes smaller than this value will not be swapped. This reduces the number of swap/load operations. You can retrieve or set the minimum size using the getMinSize() and setMinSize($newSize) methods: $oldMinSize = $memoryManager->getMinSize(); // Get MinSize in bytes $memoryManager->setMinSize($newSize); // Set MinSize limit in bytes The default minimum size value is 16KB (16384 bytes).","title":"Memory Manager"},{"location":"memory-manager/#memory-manager","text":"","title":"Memory Manager"},{"location":"memory-manager/#creating-a-memory-manager","text":"You can create new a memory manager ( Zend\\Memory\\MemoryManager object) using its constructor: __construct(Zend\\Cache\\Storage\\StorageInterface $cache = null) : void As an example, the following creates an instance which is not backed by cache storage: $memoryManager = new Zend\\Memory\\MemoryManager(); While the following creates an instance backed by a filesystem cache storage adapter, storing memory blocks in the tmp/ directory of the current working directory: use Zend\\Cache\\StorageFactory; use Zend\\Memory\\MemoryManager; $cache = StorageFactory::factory([ 'adapter' => [ 'name' => 'Filesystem', 'options' => [ 'cache_dir' => './tmp/', // Directory in which to put swapped memory blocks ], ], ]); $memoryManager = new MemoryManager($cache); The MemoryManager uses zend-cache storage adapters to cache memory blocks; if no cache instance is provided, the system temporary directory is used. This is useful if you know that memory is not limited or the overall size of objects never reaches the memory limit.","title":"Creating a Memory Manager"},{"location":"memory-manager/#managing-memory-objects","text":"This section describes creating and destroying objects in the managed memory, and settings to control memory manager behavior.","title":"Managing Memory Objects"},{"location":"memory-manager/#settings","text":"","title":"Settings"},{"location":"memory-objects/","text":"Memory Objects Movable \"Movable\" memory objects are ones that may be swapped into the cache backend and unloaded from memory when not in active use. Create movable memory objects using the create([$data]) method of the memory manager: $memObject = $memoryManager->create($data); Such objects will be retrieved from the cache and/or memor when accessed again. Locked \"Locked\" memory objects will never be swapped to cache or unloaded from memory. Create locked memory objects using the createLocked([$data]) method of the memory manager: $memObject = $memoryManager->createLocked($data); Locked objects implement the same interface as movable objects ( Zend\\Memory\\Container\\Interface ), and can be used interchangably with movable objects. Use them when you have performance considerations that dictate keeping the information in memory. Access to locked objects is faster, because the memory manager doesn't need to track changes for these objects. The locked objects class ( Zend\\Memory\\Container\\Locked ) guarantees virtually the same performance as working with a string variable. The overhead is a single dereference to get the class property. Memory container 'value' property Use the memory container (movable or locked) value property to operate with memory object data: $memObject = $memoryManager->create($data); echo $memObject->value; $memObject->value = $newValue; $memObject->value[$index] = '_'; echo ord($memObject->value[$index1]); $memObject->value = substr($memObject->value, $start, $length); An alternative way to access memory object data is to use the getRef() ; method. Memory container interface Each memory container type provides the following methods: getRef() method &getRef() : mixed The getRef() method returns a reference to the object value. Movable objects are loaded from the cache at this moment if the object is not already in memory. If the object is loaded from the cache, this might cause swapping of other objects if the memory limit would be exceeded by having all the managed objects in memory. Tracking changes to data needs additional resources. The getRef() method returns a reference to the string value used to store the data, which is changed directly by user application. Use the getRef() method for value data processing where you want to ensure the data changes without necessarily interacting directly with the memory container: $memObject = $memoryManager->create($data); $value = &$memObject->getRef(); for ($count = 0; $count < strlen($value); $count++) { $char = $value[$count]; // ... } touch() method touch() : void The touch() method should be used in conjunction with getRef() . It signals that object value has been changed: $memObject = $memoryManager->create($data); ... $value = &$memObject->getRef(); for ($count = 0; $count < strlen($value); $count++) { // ... if ($condition) { $value[$count] = $char; } // ... } $memObject->touch(); lock() method lock() : void The lock() methods locks the object in memory. It should be used to prevent swapping of the object. Normally, this is not necessary, because the memory manager uses an intelligent algorithm to choose candidates for swapping. But if you know that at a specific point in the code an object should not be swapped, you may lock it. Locking objects in memory also guarantees that the reference returned by the getRef() method is valid until you unlock the object: $memObject1 = $memoryManager->create($data1); $memObject2 = $memoryManager->create($data2); ... $memObject1->lock(); $memObject2->lock(); $value1 = &$memObject1->getRef(); $value2 = &$memObject2->getRef(); for ($count = 0; $count < strlen($value2); $count++) { $value1 .= $value2[$count]; } $memObject1->touch(); $memObject1->unlock(); $memObject2->unlock(); unlock() method unlock() : void The unlock() method unlocks object when it's no longer necessary to be locked. See the example above. isLocked() method isLocked() : bool The isLocked() method can be used to check if object is locked. It returns true if the object is locked, or false if it is not locked. This is always true for \"locked\" objects, and may be either true or false for \"movable\" objects.","title":"Memory Objects"},{"location":"memory-objects/#memory-objects","text":"","title":"Memory Objects"},{"location":"memory-objects/#movable","text":"\"Movable\" memory objects are ones that may be swapped into the cache backend and unloaded from memory when not in active use. Create movable memory objects using the create([$data]) method of the memory manager: $memObject = $memoryManager->create($data); Such objects will be retrieved from the cache and/or memor when accessed again.","title":"Movable"},{"location":"memory-objects/#locked","text":"\"Locked\" memory objects will never be swapped to cache or unloaded from memory. Create locked memory objects using the createLocked([$data]) method of the memory manager: $memObject = $memoryManager->createLocked($data); Locked objects implement the same interface as movable objects ( Zend\\Memory\\Container\\Interface ), and can be used interchangably with movable objects. Use them when you have performance considerations that dictate keeping the information in memory. Access to locked objects is faster, because the memory manager doesn't need to track changes for these objects. The locked objects class ( Zend\\Memory\\Container\\Locked ) guarantees virtually the same performance as working with a string variable. The overhead is a single dereference to get the class property.","title":"Locked"},{"location":"memory-objects/#memory-container-value-property","text":"Use the memory container (movable or locked) value property to operate with memory object data: $memObject = $memoryManager->create($data); echo $memObject->value; $memObject->value = $newValue; $memObject->value[$index] = '_'; echo ord($memObject->value[$index1]); $memObject->value = substr($memObject->value, $start, $length); An alternative way to access memory object data is to use the getRef() ; method.","title":"Memory container 'value' property"},{"location":"memory-objects/#memory-container-interface","text":"Each memory container type provides the following methods:","title":"Memory container interface"}]}