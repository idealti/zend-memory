{
    "docs": [
        {
            "location": "/",
            "text": "../../README.md",
            "title": "Home"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nzend-memory assists with managing data in an environment with limited memory.\n\n\nMemory objects (memory containers) are generated by the memory manager at your\nrequest and transparently swapped/loaded when necessary.\n\n\nFor example, if creating or loading a managed object would cause the total\nmemory usage to exceed the limit you specify, some managed objects are copied to\ncache storage outside of memory. In this way, the total memory used by managed\nobjects does not exceed the limit you need to enforce. To provide this\nfunctionality, the memory manager can compose \nzend-cache storage adapters\n\nas storage providers.\n\n\nUsage\n\n\nInstantiate the memory manager class:\n\n\nuse Zend\\Memory\\MemoryManager;\n\n// No caching backend:\n$memoryManager = new MemoryManager();\n\n\n\nOptionally, you can create a cache storage adapter, and pass it to the\n\nMemoryManager\n constructor:\n\n\nuse Zend\\Cache\\StorageFactory;\nuse Zend\\Memory\\MemoryManager;\n\n// Use a filesystem adapter, placing memory blocks in the tmp directory\n// under which the application is running.\n$cache = StorageFactory::factory([\n    'adapter' => [\n        'name' => 'filesystem',\n        'options' => ['cache_dir' => './tmp/'],\n    ],\n]);\n\n$memoryManager = new MemoryManager($cache);\n\n\n\nOnce you have a \nMemoryManager\n instance, you can start pushing values to it and\npulling values from it.\n\n\n$loadedFiles = array();\n\nfor ($count = 0; $count < 10000; $count++) {\n    $f = fopen($fileNames[$count], 'rb');\n    $data = fread($f, filesize($fileNames[$count]));\n    $fclose($f);\n\n    $loadedFiles[] = $memoryManager->create($data);\n}\n\necho $loadedFiles[$index1]->value;\n\n$loadedFiles[$index2]->value = $newValue;\n\n$loadedFiles[$index3]->value[$charIndex] = '_';\n\n\n\nTheory of Operation\n\n\nzend-memory operates with the following concepts:\n\n\n\n\nMemory manager\n\n\nMemory container\n\n\nLocked memory object\n\n\nMovable memory object\n\n\n\n\nMemory manager\n\n\nThe memory manager generates memory objects (locked or movable) by request of\nthe application, and returns them wrapped into a memory container object.\n\n\nMemory container\n\n\nThe memory container has a virtual or actual \nvalue\n attribute of type \nstring\n.\nThis attribute contains the data value specified at memory object creation time.\n\n\nYou can operate with this \nvalue\n attribute as an object property:\n\n\n$memObject = $memoryManager->create($data);\n\necho $memObject->value;\n\n$memObject->value = $newValue;\n\n$memObject->value[$index] = '_';\n\necho ord($memObject->value[$index1]);\n\n$memObject->value = substr($memObject->value, $start, $length);\n\n\n\nLocked memory\n\n\nLocked memory objects are always stored in memory. Data stored in locked memory\nare never swapped to the cache backend.\n\n\nMovable memory\n\n\nMovable memory objects are transparently swapped and loaded to/from the cache\nbackend by the \nMemoryManager\n when necessary.\n\n\nThe memory manager does not swap objects with size less than the specified\nminimum, due to performance considerations. See \nthe settings section\n\nfor more details.",
            "title": "Intro"
        },
        {
            "location": "/intro/#introduction",
            "text": "zend-memory assists with managing data in an environment with limited memory.  Memory objects (memory containers) are generated by the memory manager at your\nrequest and transparently swapped/loaded when necessary.  For example, if creating or loading a managed object would cause the total\nmemory usage to exceed the limit you specify, some managed objects are copied to\ncache storage outside of memory. In this way, the total memory used by managed\nobjects does not exceed the limit you need to enforce. To provide this\nfunctionality, the memory manager can compose  zend-cache storage adapters \nas storage providers.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#usage",
            "text": "Instantiate the memory manager class:  use Zend\\Memory\\MemoryManager;\n\n// No caching backend:\n$memoryManager = new MemoryManager();  Optionally, you can create a cache storage adapter, and pass it to the MemoryManager  constructor:  use Zend\\Cache\\StorageFactory;\nuse Zend\\Memory\\MemoryManager;\n\n// Use a filesystem adapter, placing memory blocks in the tmp directory\n// under which the application is running.\n$cache = StorageFactory::factory([\n    'adapter' => [\n        'name' => 'filesystem',\n        'options' => ['cache_dir' => './tmp/'],\n    ],\n]);\n\n$memoryManager = new MemoryManager($cache);  Once you have a  MemoryManager  instance, you can start pushing values to it and\npulling values from it.  $loadedFiles = array();\n\nfor ($count = 0; $count < 10000; $count++) {\n    $f = fopen($fileNames[$count], 'rb');\n    $data = fread($f, filesize($fileNames[$count]));\n    $fclose($f);\n\n    $loadedFiles[] = $memoryManager->create($data);\n}\n\necho $loadedFiles[$index1]->value;\n\n$loadedFiles[$index2]->value = $newValue;\n\n$loadedFiles[$index3]->value[$charIndex] = '_';",
            "title": "Usage"
        },
        {
            "location": "/intro/#theory-of-operation",
            "text": "zend-memory operates with the following concepts:   Memory manager  Memory container  Locked memory object  Movable memory object",
            "title": "Theory of Operation"
        },
        {
            "location": "/intro/#memory-manager",
            "text": "The memory manager generates memory objects (locked or movable) by request of\nthe application, and returns them wrapped into a memory container object.",
            "title": "Memory manager"
        },
        {
            "location": "/intro/#memory-container",
            "text": "The memory container has a virtual or actual  value  attribute of type  string .\nThis attribute contains the data value specified at memory object creation time.  You can operate with this  value  attribute as an object property:  $memObject = $memoryManager->create($data);\n\necho $memObject->value;\n\n$memObject->value = $newValue;\n\n$memObject->value[$index] = '_';\n\necho ord($memObject->value[$index1]);\n\n$memObject->value = substr($memObject->value, $start, $length);",
            "title": "Memory container"
        },
        {
            "location": "/intro/#locked-memory",
            "text": "Locked memory objects are always stored in memory. Data stored in locked memory\nare never swapped to the cache backend.",
            "title": "Locked memory"
        },
        {
            "location": "/intro/#movable-memory",
            "text": "Movable memory objects are transparently swapped and loaded to/from the cache\nbackend by the  MemoryManager  when necessary.  The memory manager does not swap objects with size less than the specified\nminimum, due to performance considerations. See  the settings section \nfor more details.",
            "title": "Movable memory"
        },
        {
            "location": "/memory-manager/",
            "text": "Memory Manager\n\n\nCreating a Memory Manager\n\n\nYou can create new a memory manager (\nZend\\Memory\\MemoryManager\n object) using its constructor:\n\n\n__construct(Zend\\Cache\\Storage\\StorageInterface $cache = null) : void\n\n\n\nAs an example, the following creates an instance which \nis not\n backed by cache\nstorage:\n\n\n$memoryManager = new Zend\\Memory\\MemoryManager();\n\n\n\nWhile the following creates an instance backed by a filesystem cache storage\nadapter, storing memory blocks in the \ntmp/\n directory of the current working\ndirectory:\n\n\nuse Zend\\Cache\\StorageFactory;\nuse Zend\\Memory\\MemoryManager;\n\n$cache = StorageFactory::factory([\n    'adapter' => [\n        'name' => 'Filesystem',\n        'options' => [\n            'cache_dir' => './tmp/', // Directory in which to put swapped memory blocks\n        ],\n    ],\n]);\n\n$memoryManager = new MemoryManager($cache);\n\n\n\nThe \nMemoryManager\n uses \nzend-cache storage adapters\n\nto cache memory blocks; if no cache instance is provided, the system temporary\ndirectory is used. This is useful if you know that memory is not limited or the\noverall size of objects never reaches the memory limit.\n\n\nManaging Memory Objects\n\n\nThis section describes creating and destroying objects in the managed memory,\nand settings to control memory manager behavior.\n\n\nCreating Movable Objects\n\n\nCreate movable objects (objects which may be swapped into cache storage) using\nthe \nZend\\Memory\\MemoryManager::create([$data])\n method:\n\n\n$memObject = $memoryManager->create($data);\n\n\n\nThe \n$data\n argument is optional and used to initialize the object value. If the\n\n$data\n argument is omitted, the value is an empty string.\n\n\nCreating Locked Objects\n\n\nCreate locked objects (objects which will never be swapped into cache storage)\nusing the \nZend\\Memory\\MemoryManager::createLocked([$data])\n method:\n\n\n$memObject = $memoryManager->createLocked($data);\n\n\n\nThe \n$data\n argument is optional and used to initialize the object value. If the\n\n$data\n argument is omitted, the value is an empty string.\n\n\nDestroying Objects\n\n\nMemory objects are automatically destroyed and removed from memory when they go\nout of scope:\n\n\nfunction foo() use ($memoryManager, $memList) {\n    // ...\n\n    $memObject1 = $memoryManager->create($data1);\n    $memObject2 = $memoryManager->create($data2);\n    $memObject3 = $memoryManager->create($data3);\n\n    // ...\n\n    $memList[] = $memObject3;\n\n    // ...\n\n    unset($memObject2); // $memObject2 is destroyed here\n\n    // ...\n    // $memObject1 is destroyed here\n    // but $memObject3 object is still referenced by $memList\n    // and is not destroyed\n}\n\n\n\nThis applies to both movable and locked objects.\n\n\nSettings\n\n\nMemory Limit\n\n\nThe memory limit is the maximum number of bytes allowed for use by loaded\nmovable objects.\n\n\nIf loading or creation of an object causes memory usage to exceed of this limit,\nthen the memory manager swaps some other objects.\n\n\nYou can retrieve or set the memory limit setting using the \ngetMemoryLimit()\n and\n\nsetMemoryLimit($newLimit)\n methods:\n\n\n$oldLimit = $memoryManager->getMemoryLimit();  // Get memory limit in bytes\n$memoryManager->setMemoryLimit($newLimit);     // Set memory limit in bytes\n\n\n\nA negative value for memory limit means 'no limit'.\n\n\nThe default value is two-thirds of the value of \nmemory_limit\n in \nphp.ini\n or\n'no limit' (-1) if \nmemory_limit\n is not set in \nphp.ini\n.\n\n\nMinSize\n\n\nThe \nMinSize\n is the minimum size an object must be before it will be swapped to a\ncache backend; objects with sizes smaller than this value will not be swapped.\nThis reduces the number of swap/load operations.\n\n\nYou can retrieve or set the minimum size using the \ngetMinSize()\n and\n\nsetMinSize($newSize)\n methods:\n\n\n$oldMinSize = $memoryManager->getMinSize();  // Get MinSize in bytes\n$memoryManager->setMinSize($newSize);        // Set MinSize limit in bytes\n\n\n\nThe default minimum size value is 16KB (16384 bytes).",
            "title": "Memory Manager"
        },
        {
            "location": "/memory-manager/#memory-manager",
            "text": "",
            "title": "Memory Manager"
        },
        {
            "location": "/memory-manager/#creating-a-memory-manager",
            "text": "You can create new a memory manager ( Zend\\Memory\\MemoryManager  object) using its constructor:  __construct(Zend\\Cache\\Storage\\StorageInterface $cache = null) : void  As an example, the following creates an instance which  is not  backed by cache\nstorage:  $memoryManager = new Zend\\Memory\\MemoryManager();  While the following creates an instance backed by a filesystem cache storage\nadapter, storing memory blocks in the  tmp/  directory of the current working\ndirectory:  use Zend\\Cache\\StorageFactory;\nuse Zend\\Memory\\MemoryManager;\n\n$cache = StorageFactory::factory([\n    'adapter' => [\n        'name' => 'Filesystem',\n        'options' => [\n            'cache_dir' => './tmp/', // Directory in which to put swapped memory blocks\n        ],\n    ],\n]);\n\n$memoryManager = new MemoryManager($cache);  The  MemoryManager  uses  zend-cache storage adapters \nto cache memory blocks; if no cache instance is provided, the system temporary\ndirectory is used. This is useful if you know that memory is not limited or the\noverall size of objects never reaches the memory limit.",
            "title": "Creating a Memory Manager"
        },
        {
            "location": "/memory-manager/#managing-memory-objects",
            "text": "This section describes creating and destroying objects in the managed memory,\nand settings to control memory manager behavior.",
            "title": "Managing Memory Objects"
        },
        {
            "location": "/memory-manager/#creating-movable-objects",
            "text": "Create movable objects (objects which may be swapped into cache storage) using\nthe  Zend\\Memory\\MemoryManager::create([$data])  method:  $memObject = $memoryManager->create($data);  The  $data  argument is optional and used to initialize the object value. If the $data  argument is omitted, the value is an empty string.",
            "title": "Creating Movable Objects"
        },
        {
            "location": "/memory-manager/#creating-locked-objects",
            "text": "Create locked objects (objects which will never be swapped into cache storage)\nusing the  Zend\\Memory\\MemoryManager::createLocked([$data])  method:  $memObject = $memoryManager->createLocked($data);  The  $data  argument is optional and used to initialize the object value. If the $data  argument is omitted, the value is an empty string.",
            "title": "Creating Locked Objects"
        },
        {
            "location": "/memory-manager/#destroying-objects",
            "text": "Memory objects are automatically destroyed and removed from memory when they go\nout of scope:  function foo() use ($memoryManager, $memList) {\n    // ...\n\n    $memObject1 = $memoryManager->create($data1);\n    $memObject2 = $memoryManager->create($data2);\n    $memObject3 = $memoryManager->create($data3);\n\n    // ...\n\n    $memList[] = $memObject3;\n\n    // ...\n\n    unset($memObject2); // $memObject2 is destroyed here\n\n    // ...\n    // $memObject1 is destroyed here\n    // but $memObject3 object is still referenced by $memList\n    // and is not destroyed\n}  This applies to both movable and locked objects.",
            "title": "Destroying Objects"
        },
        {
            "location": "/memory-manager/#settings",
            "text": "",
            "title": "Settings"
        },
        {
            "location": "/memory-manager/#memory-limit",
            "text": "The memory limit is the maximum number of bytes allowed for use by loaded\nmovable objects.  If loading or creation of an object causes memory usage to exceed of this limit,\nthen the memory manager swaps some other objects.  You can retrieve or set the memory limit setting using the  getMemoryLimit()  and setMemoryLimit($newLimit)  methods:  $oldLimit = $memoryManager->getMemoryLimit();  // Get memory limit in bytes\n$memoryManager->setMemoryLimit($newLimit);     // Set memory limit in bytes  A negative value for memory limit means 'no limit'.  The default value is two-thirds of the value of  memory_limit  in  php.ini  or\n'no limit' (-1) if  memory_limit  is not set in  php.ini .",
            "title": "Memory Limit"
        },
        {
            "location": "/memory-manager/#minsize",
            "text": "The  MinSize  is the minimum size an object must be before it will be swapped to a\ncache backend; objects with sizes smaller than this value will not be swapped.\nThis reduces the number of swap/load operations.  You can retrieve or set the minimum size using the  getMinSize()  and setMinSize($newSize)  methods:  $oldMinSize = $memoryManager->getMinSize();  // Get MinSize in bytes\n$memoryManager->setMinSize($newSize);        // Set MinSize limit in bytes  The default minimum size value is 16KB (16384 bytes).",
            "title": "MinSize"
        },
        {
            "location": "/memory-objects/",
            "text": "Memory Objects\n\n\nMovable\n\n\n\"Movable\" memory objects are ones that may be swapped into the cache backend and\nunloaded from memory when not in active use.\n\n\nCreate movable memory objects using the \ncreate([$data])\n method of the memory\nmanager:\n\n\n$memObject = $memoryManager->create($data);\n\n\n\nSuch objects will be retrieved from the cache and/or memor when accessed again.\n\n\nLocked\n\n\n\"Locked\" memory objects will never be swapped to cache or unloaded from memory.\n\n\nCreate locked memory objects using the \ncreateLocked([$data])\n method of the\nmemory manager:\n\n\n$memObject = $memoryManager->createLocked($data);\n\n\n\nLocked objects implement the same interface as movable objects\n(\nZend\\Memory\\Container\\Interface\n), and can be used interchangably with movable\nobjects. Use them when you have performance considerations that dictate keeping\nthe information in memory. Access to locked objects is faster, because the\nmemory manager doesn't need to track changes for these objects.\n\n\nThe locked objects class (\nZend\\Memory\\Container\\Locked\n) guarantees virtually\nthe same performance as working with a string variable. The overhead is a single\ndereference to get the class property.\n\n\nMemory container 'value' property\n\n\nUse the memory container (movable or locked) \nvalue\n property to operate with\nmemory object data:\n\n\n$memObject = $memoryManager->create($data);\n\necho $memObject->value;\n\n$memObject->value = $newValue;\n\n$memObject->value[$index] = '_';\n\necho ord($memObject->value[$index1]);\n\n$memObject->value = substr($memObject->value, $start, $length);\n\n\n\nAn alternative way to access memory object data is to use the\n\ngetRef()\n; method.\n\n\nMemory container interface\n\n\nEach memory container type provides the following methods:\n\n\ngetRef() method\n\n\n&getRef() : mixed\n\n\n\nThe \ngetRef()\n method returns a reference to the object value.\n\n\nMovable objects are loaded from the cache at this moment if the object is not\nalready in memory. If the object is loaded from the cache, this might cause\nswapping of other objects if the memory limit would be exceeded by having all\nthe managed objects in memory.\n\n\nTracking changes to data needs additional resources. The \ngetRef()\n method\nreturns a reference to the string value used to store the data, which is changed\ndirectly by user application. Use the \ngetRef()\n method for value data\nprocessing where you want to ensure the data changes without necessarily\ninteracting directly with the memory container:\n\n\n$memObject = $memoryManager->create($data);\n\n$value = &$memObject->getRef();\n\nfor ($count = 0; $count < strlen($value); $count++) {\n    $char = $value[$count];\n    // ...\n}\n\n\n\ntouch() method\n\n\ntouch() : void\n\n\n\nThe \ntouch()\n method should be used in conjunction with \ngetRef()\n. It signals\nthat object value has been changed:\n\n\n$memObject = $memoryManager->create($data);\n...\n\n$value = &$memObject->getRef();\n\nfor ($count = 0; $count < strlen($value); $count++) {\n    // ...\n    if ($condition) {\n        $value[$count] = $char;\n    }\n    // ...\n}\n\n$memObject->touch();\n\n\n\nlock() method\n\n\nlock() : void\n\n\n\nThe \nlock()\n methods locks the object in memory. It should be used to prevent\nswapping of the object.  Normally, this is not necessary, because the memory\nmanager uses an intelligent algorithm to choose candidates for swapping. But if\nyou know that at a specific point in the code an object should not be swapped,\nyou may lock it.\n\n\nLocking objects in memory also guarantees that the reference returned by the\n\ngetRef()\n method is valid until you unlock the object:\n\n\n$memObject1 = $memoryManager->create($data1);\n$memObject2 = $memoryManager->create($data2);\n...\n\n$memObject1->lock();\n$memObject2->lock();\n\n$value1 = &$memObject1->getRef();\n$value2 = &$memObject2->getRef();\n\nfor ($count = 0; $count < strlen($value2); $count++) {\n    $value1 .= $value2[$count];\n}\n\n$memObject1->touch();\n$memObject1->unlock();\n$memObject2->unlock();\n\n\n\nunlock() method\n\n\nunlock() : void\n\n\n\nThe \nunlock()\n method unlocks object when it's no longer necessary to be locked.\nSee the example above.\n\n\nisLocked() method\n\n\nisLocked() : bool\n\n\n\nThe \nisLocked()\n method can be used to check if object is locked. It returns\n\ntrue\n if the object is locked, or \nfalse\n if it is not locked. This is always\n\ntrue\n for \"locked\" objects, and may be either \ntrue\n or \nfalse\n for \"movable\"\nobjects.",
            "title": "Memory Objects"
        },
        {
            "location": "/memory-objects/#memory-objects",
            "text": "",
            "title": "Memory Objects"
        },
        {
            "location": "/memory-objects/#movable",
            "text": "\"Movable\" memory objects are ones that may be swapped into the cache backend and\nunloaded from memory when not in active use.  Create movable memory objects using the  create([$data])  method of the memory\nmanager:  $memObject = $memoryManager->create($data);  Such objects will be retrieved from the cache and/or memor when accessed again.",
            "title": "Movable"
        },
        {
            "location": "/memory-objects/#locked",
            "text": "\"Locked\" memory objects will never be swapped to cache or unloaded from memory.  Create locked memory objects using the  createLocked([$data])  method of the\nmemory manager:  $memObject = $memoryManager->createLocked($data);  Locked objects implement the same interface as movable objects\n( Zend\\Memory\\Container\\Interface ), and can be used interchangably with movable\nobjects. Use them when you have performance considerations that dictate keeping\nthe information in memory. Access to locked objects is faster, because the\nmemory manager doesn't need to track changes for these objects.  The locked objects class ( Zend\\Memory\\Container\\Locked ) guarantees virtually\nthe same performance as working with a string variable. The overhead is a single\ndereference to get the class property.",
            "title": "Locked"
        },
        {
            "location": "/memory-objects/#memory-container-value-property",
            "text": "Use the memory container (movable or locked)  value  property to operate with\nmemory object data:  $memObject = $memoryManager->create($data);\n\necho $memObject->value;\n\n$memObject->value = $newValue;\n\n$memObject->value[$index] = '_';\n\necho ord($memObject->value[$index1]);\n\n$memObject->value = substr($memObject->value, $start, $length);  An alternative way to access memory object data is to use the getRef() ; method.",
            "title": "Memory container 'value' property"
        },
        {
            "location": "/memory-objects/#memory-container-interface",
            "text": "Each memory container type provides the following methods:",
            "title": "Memory container interface"
        },
        {
            "location": "/memory-objects/#getref-method",
            "text": "&getRef() : mixed  The  getRef()  method returns a reference to the object value.  Movable objects are loaded from the cache at this moment if the object is not\nalready in memory. If the object is loaded from the cache, this might cause\nswapping of other objects if the memory limit would be exceeded by having all\nthe managed objects in memory.  Tracking changes to data needs additional resources. The  getRef()  method\nreturns a reference to the string value used to store the data, which is changed\ndirectly by user application. Use the  getRef()  method for value data\nprocessing where you want to ensure the data changes without necessarily\ninteracting directly with the memory container:  $memObject = $memoryManager->create($data);\n\n$value = &$memObject->getRef();\n\nfor ($count = 0; $count < strlen($value); $count++) {\n    $char = $value[$count];\n    // ...\n}",
            "title": "getRef() method"
        },
        {
            "location": "/memory-objects/#touch-method",
            "text": "touch() : void  The  touch()  method should be used in conjunction with  getRef() . It signals\nthat object value has been changed:  $memObject = $memoryManager->create($data);\n...\n\n$value = &$memObject->getRef();\n\nfor ($count = 0; $count < strlen($value); $count++) {\n    // ...\n    if ($condition) {\n        $value[$count] = $char;\n    }\n    // ...\n}\n\n$memObject->touch();",
            "title": "touch() method"
        },
        {
            "location": "/memory-objects/#lock-method",
            "text": "lock() : void  The  lock()  methods locks the object in memory. It should be used to prevent\nswapping of the object.  Normally, this is not necessary, because the memory\nmanager uses an intelligent algorithm to choose candidates for swapping. But if\nyou know that at a specific point in the code an object should not be swapped,\nyou may lock it.  Locking objects in memory also guarantees that the reference returned by the getRef()  method is valid until you unlock the object:  $memObject1 = $memoryManager->create($data1);\n$memObject2 = $memoryManager->create($data2);\n...\n\n$memObject1->lock();\n$memObject2->lock();\n\n$value1 = &$memObject1->getRef();\n$value2 = &$memObject2->getRef();\n\nfor ($count = 0; $count < strlen($value2); $count++) {\n    $value1 .= $value2[$count];\n}\n\n$memObject1->touch();\n$memObject1->unlock();\n$memObject2->unlock();",
            "title": "lock() method"
        },
        {
            "location": "/memory-objects/#unlock-method",
            "text": "unlock() : void  The  unlock()  method unlocks object when it's no longer necessary to be locked.\nSee the example above.",
            "title": "unlock() method"
        },
        {
            "location": "/memory-objects/#islocked-method",
            "text": "isLocked() : bool  The  isLocked()  method can be used to check if object is locked. It returns true  if the object is locked, or  false  if it is not locked. This is always true  for \"locked\" objects, and may be either  true  or  false  for \"movable\"\nobjects.",
            "title": "isLocked() method"
        }
    ]
}